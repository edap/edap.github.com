<html lang="en">

<head>
  <title> 2D animated pattern, Davide Prati, 2020</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      margin: 0px;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <script src="../../js/three.min.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
  void main()	{
      gl_Position = vec4( position, 1.0 );
  }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">

// glslViewer denti/third.frag ../textures/sunbittern-bw.jpg ../textures/sunbittern4.jpg

#include "../libs/wallpaperGroups.glsl"

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform sampler2D u_tex0;
uniform sampler2D u_tex1;
uniform float u_time;

#define palette 3
#define PI 3.14159265359
#define PATTERN_DIM 1040.0
// 5
#define group 5
#define offset 0.0
const float rotation = 0.0;
const vec2 scalingGroup = vec2(1.,1.);

#include "../libs/rectSDF.glsl"
#include "../libs/noise.glsl"

vec2 rotate(vec2 st, float a) {
  st = mat2(cos(a),-sin(a),
            sin(a),cos(a))*(st-.5);
  return st+.5;
}

#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
#endif
float aastep(float threshold, float value) {
    #ifdef GL_OES_standard_derivatives
    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));
    return smoothstep(threshold-afwidth, threshold+afwidth, value);
    #else
    return step(threshold, value);
    #endif
}

float fill(float x, float size) {
  return 1.-aastep(size, x);
}

float substract(float d1, float d2){
	return max(-d1, d2);
}

float sdCircle(vec2 p, float r ){
  return length(p) - r;
}

// if longY is bigger than 0.1 then the stripes
// goes from top to 
float denti(vec2 pos, float yOff){
  float result;
  float doOff = step(0., pos.x);

  float gradUp = fract(pos.y+yOff);
  float gradDown = fract(pos.y-yOff);
  result = -gradUp * (doOff);
  result += gradDown * (1.0-doOff);

  //return abs(yy);
  //return mod(yy, 0.7);
  //return doOffY;
  return fract(result);
}

void main(){
  // general variables
  vec2 uv = (2.0 * gl_FragCoord.xy - u_resolution.xy)/ u_resolution.y;
  float scale = 1.5;
  float scaleBg = 1.0;
  float zoomGroup = 800.;

  vec3 coloreUno;
  vec3 coloreDue;
  vec3 coloreTre;
  vec3 coloreQuattro;
  vec3 coloreCinque;
  if(palette == 1){
    coloreUno = vec3(0.733, 1.0, 0.31);
    coloreDue = vec3(1.0, 0.353, 0.208);
    coloreTre = vec3(0.086, 0.29, 0.8);
    coloreQuattro = vec3(0.698, 0.188, 0.075);
    coloreCinque = vec3( 0.098, 0.0, 0.749);
  }
  if (palette == 2){
    coloreUno = vec3(1., 0.592, 0.706);
    coloreDue = vec3(0.898, 0.341, 0.878);
    coloreTre = vec3(0.902, 0.494, 0.063);
    coloreQuattro = vec3(0., 0.498, 0.353);
    coloreCinque = vec3(0.098, 0, 0.749);
  }
  if (palette == 3){
    coloreUno = vec3(0.965, 0.914, 0.396);
    coloreDue = vec3(0.333, 1, 0.235);
    coloreTre = vec3(0.078, 0.643, 0.8);
    coloreQuattro = vec3(0.706, .0, 0.514);
    coloreCinque = vec3(.0, .0, .0);  
  }
  if (palette == 4){
    coloreUno = vec3(0.055, 0.8, 0.812);
    coloreDue = vec3(0.965, 0.914, 0.396);
    coloreTre = vec3(0.902, 0.659, 0.141);
    coloreQuattro = vec3(0.953, 0.447, 0.035);
    coloreCinque = vec3(1., 0.267, 0.016);  
  }
  if (palette == 5){
    coloreUno = vec3(0.055, 0.8, 0.812);
    coloreDue = vec3(0.702, 0.839, 0.38);
    coloreTre = vec3(0.945, 0.757, 0.137);
    coloreQuattro = vec3(0.902, 0.659, 0.141);
    coloreCinque = vec3(0.525, 0.094, 0.949);  
  }


  // coordinate fields
  vec2 strecthedDentiUv = vec2(uv.x*20.0*scale, uv.y*6.*scale);
  vec2 stDenti = vec2(0.5) - fract(strecthedDentiUv);
  vec2 stDiagonal = rotate((vec2(0.5) - uv), PI/4.0);
  vec2 stRombi = fract(stDiagonal * scale);
  vec2 stBg = fract(stDiagonal * scaleBg);
  vec3 tex1R = texture2D(u_tex1, stRombi).xyz;
  vec3 tex0R = texture2D(u_tex0, stRombi).xyz;
  vec3 tex0 = texture2D(u_tex0,gl_FragCoord.xy/ u_resolution.xy).xyz;
  vec3 tex1 = texture2D(u_tex1,gl_FragCoord.xy/ u_resolution.xy).xyz;

  // noise field
  float zoom = 2.0;
  vec2 dottedField = vectorFieldMg(uv, 12.1, 2.9, 3.9, 4.5, 0.0) * 2.0;
  dottedField = fract(dottedField)-vec2(0.5);
  float dots = sdCircle(dottedField, 0.4);
  float dotMask = smoothstep(0.01, 0.07, dots);

  // background Holes
  vec2 holesField = vectorFieldMg(uv, 6.4, 5., 0.8, 0.2, 0.0) * scaleBg;
  holesField = fract(holesField)-vec2(0.5);
  float holes = sdCircle(holesField, 0.2);
  float holesMask = smoothstep(0.1, 0.25, holes);

  float thickness = 0.045;


  
  // ELEMENTS


  float sideRombo =1.7;

  // center rombo
  float centerRombi = rectSDF(stRombi, vec2(sideRombo*0.5));
  float fillCenterRombi = fill(centerRombi, .4);

  //rombo bordo spesso
  float rombi = rectSDF(stRombi, vec2(sideRombo));
  float fillRombi = fill(rombi, .4) - fillCenterRombi;


  // luce
  vec2 offsetLuce = vec2(+0.0, -0.0);
  float rombiLuce = rectSDF(stRombi-(offsetLuce), vec2(sideRombo * 1.2));
  float fillRombiLuce = fill(rombiLuce, .4);
  fillRombiLuce -= fillRombi;
  fillRombiLuce -= fillCenterRombi;

  // background
  float background = max(.0, 1. - fillRombiLuce - fillRombi - fillCenterRombi);


  // COLORS
  // denti
  // repetition also on y
  // float str = denti(rep, sin(u_time) * 0.5 , rep.y);
  // float str = denti(rep, 0.4, uv.y);
  float den = denti(stDenti, -0.5);
  vec3 color = vec3(0.0);
  vec3 colorRombo = vec3(0.0);

  // wallpaper background
  vec2 pos = gl_FragCoord.xy;
  float xt, yt;
  xt = pos.x * cos(rotation) * scalingGroup.x + pos.y * sin(rotation) * scalingGroup.y;
  yt = -pos.x * sin(rotation) * scalingGroup.x + pos.y * cos(rotation) * scalingGroup.y;
  xt -= u_resolution.x / 2.;
  yt -= u_resolution.y / 2.;
  vec2 groupCoord = stBg - vec2(.5);
  pos = getGroup(group, groupCoord.x*zoomGroup, groupCoord.y * zoomGroup, PATTERN_DIM, offset);
  vec4 groupPiume = vec4(texture2D(u_tex1, pos));
  vec3 bgColor = mix(coloreDue, coloreTre, groupPiume.b) *holesMask;
  bgColor += mix(coloreTre, coloreDue, groupPiume.b) * (1. - holesMask);

  // Colora i rombi
  vec3 coloreSfondoRombo = mix(coloreDue, coloreQuattro, den);
  vec3 coloreMixRombi = mix(coloreCinque, coloreUno, tex1R.r);
  vec3 coloreLuceRombo = mix(coloreSfondoRombo, coloreMixRombi, dotMask);
  colorRombo += fillRombiLuce * coloreLuceRombo;
  colorRombo += fillCenterRombi * coloreSfondoRombo;
  colorRombo += fillRombi * coloreMixRombi;
  color += colorRombo;
  //color += fillCenterRombi * mix(coloreQuattro, coloreUno, den);



  // colora la luce
  //color += coloreUno * fillRombiLuce;
  //float luce = max(0.0, fillRombiLuce)  * den;

  // colora il bg
  // vec3 dottedCol = mix(coloreTre* tex0.b, tex0, dotMask);
  // vec3 coloreDen = mix(coloreDue, coloreQuattro, den);
  // vec3 holesCol = mix(coloreDen, tex1, holesMask);

  // post processing BW
  //vec3 bgColor =groupPiume.rgb;


  color += bgColor * background;


  // Final color
  // SINGOLI
  //gl_FragColor = vec4(vec3(fillRombiLuce), 1.0);
  //gl_FragColor = vec4(vec3(ombra), 1.0);
  //gl_FragColor = vec4(vec3(fillRombi + luce), 1.0);
  //gl_FragColor = vec4(vec3(fillCenterRombi), 1.0);
  //gl_FragColor = vec4(vec3(luce), 1.0);
  //gl_FragColor = vec4(vec3(rays), 1.0);
  //gl_FragColor = vec4(vec3(luce), 1.0);
  //gl_FragColor = vec4(vec3(holesMask), 1.0);
  //gl_FragColor = vec4(color, 1.0);
  //gl_FragColor = vec4(vec3(stDenti.x, stDenti.y, 0.0), 1.0);
  //gl_FragColor = vec4(vec3(stDiagonal.x, stDiagonal.y, 0.0), 1.0);
  //gl_FragColor = vec4(vec3(uv.x, uv.y, 0.0), 1.0);

  // MIXING
  //gl_FragColor = vec4(vec3(dentAndRomb), 1.0);
  //gl_FragColor = vec4(vec3(holesCol), 1.0);
  //gl_FragColor = vec4(color, 1.0);
  //gl_FragColor = vec4(pow(color, vec3(1./2.2)), 1.0);
  gl_FragColor = pow(vec4(color, 1.0), vec4(vec3(1./2.2), 1.0));
  


  // COLORS
  //gl_FragColor= vec4(pos.x, pos.y, 0., 1.) * fillRombi;
  //gl_FragColor = groupPiume;
  //gl_FragColor = vec4(tex1, 1.0);
  //gl_FragColor= vec4(color, 1.0);
}

</script>
<script>
var clock = new THREE.Clock();
var textureLoader = new THREE.TextureLoader();
var container, camera, scene, renderer, uniforms, material, mesh;
var i = 1.0;
var renderRequested = false;
//load assets and start
textureLoader.load('argusianus-argus2-big.jpg', texture => {
  init(texture);
  animate();
});

function init(texture0, texture1) {
  // set texture repeat
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set( 2, 2 );

  container = document.getElementById('container');
  camera = new THREE.Camera();
  camera.position.z = 1;
  scene = new THREE.Scene();
  uniforms = {
    u_time: { type: "f", value: 0.1 },
    u_resolution: { type: "v2", value: new THREE.Vector2() },
    u_tex0: {type: "t", value: texture0},
    u_tex1: {type: "t", value: texture1},
    u_mouse: {
      type: 'v2',
      value: new THREE.Vector2()
    }
  };
  material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: document.getElementById('vertexShader').textContent,
    fragmentShader: document.getElementById('fragmentShader').textContent
  });
  mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
  scene.add(mesh);
  renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
  container.appendChild(renderer.domElement);
  uniforms.u_resolution.value.x = window.innerWidth * window.devicePixelRatio;
  uniforms.u_resolution.value.y = window.innerHeight * window.devicePixelRatio ;
  renderer.setSize(window.innerWidth, window.innerHeight);

  renderer.domElement.addEventListener('mousemove', function(e) {
    updateMouseUniforms(e.clientX, e.clientY);
  });
  renderer.domElement.addEventListener('touchmove', function(e) {
    e.preventDefault();
    updateMouseUniforms(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
  });

  window.addEventListener('resize', windowResized);
}

function animate() {
  renderRequested = false;
  //uniforms.u_time.value += clock.getDelta();
  uniforms.u_time.value = i;
  renderer.render(scene, camera);
}

function requestRenderIfNotRequested() {
    if (!renderRequested) {
      renderRequested = true;
      requestAnimationFrame(animate);
    }
}

function updateMouseUniforms(clientX, clientY) {
  i += 0.05;
  uniforms.u_mouse.value.x = clientX * window.devicePixelRatio;
  uniforms.u_mouse.value.y = (window.innerHeight - clientY) * window.devicePixelRatio;
  requestRenderIfNotRequested();
}

function windowResized() {
  uniforms.u_resolution.value.x = window.innerWidth * window.devicePixelRatio;
  uniforms.u_resolution.value.y = window.innerHeight * window.devicePixelRatio ;
  renderer.setSize(window.innerWidth, window.innerHeight);
  requestRenderIfNotRequested();
}
</script>
</body>
</html>
