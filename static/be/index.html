<!doctype html>
<html lang="en">

<head>
    <style>
        body{
            background-color: black;
            margin: 0px; padding: 0px; overflow: hidden;
        }
        #wait{
            color:white;
            font-family: system-ui;
            font-size: 42px;
            z-index: 3000;
            text-align: center;
            position: absolute;
            width: 100%;
            padding-top: 15%;
        }
    </style>
    <meta charset="utf-8">
    <title>Be the sun</title>
    <meta name="description"
        content="A once in a life-time occasion to be the sun, making sunsets and sunrises whenever you want">
    <meta name="author" content="Davide Prati">
    <!-- <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/facemesh"></script> -->
    <script src="./js/regl.min.js"></script>
    <script src="./js/tf.js"></script>
	<script src="./js/facemesh.js"></script>


<script>
const FACE_UP = 10
const FACE_DOWN = 152
const NOSE_TIP = 2
const VIDEO_WIDTH = 300
const VIDEO_HEIGHT = 225
// const VIDEO_WIDTH = 1400
// const VIDEO_HEIGHT = 1050
const SUN_SIZE_MAX = 1.0
const SUN_SIZE_MIN = 0.2

let debug = false
let canvas
let fmesh
let headPosition = [200.0, 200.0]
let sunSize = 0.6
// face predictions
let curFaces = []

function map_range(value, low1, high1, low2, high2) {
    let mapped = low2 + (high2 - low2) * (value - low1) / (high1 - low1)
    return Math.min(Math.max(mapped, low2), high2)
}

async function setupCamera() {
  video = document.getElementById('video')
  const stream = await navigator.mediaDevices.getUserMedia({
    'audio': false,
    'video': {
      facingMode: 'user',
      width: {ideal:VIDEO_WIDTH},
      height: {ideal:VIDEO_HEIGHT},
    },
  })
  video.srcObject = stream

  return new Promise((resolve) => {
    video.onloadedmetadata = () => {
      resolve(video)
    }
  })
}


async function renderPrediction() {
    const facepred = await fmesh.estimateFaces(video);

    if (facepred.length > 0) { // If we find a face, process it
      curFaces = facepred
    }

  requestAnimationFrame(renderPrediction)
}

function drawVideo(){
  //ctx.drawImage(video, 0, 0);
  // TODO drawFace goes here, the sun is drawn even if the face is not detected
  for (face of curFaces){
    if (face.faceInViewConfidence > .95) {
      drawFace(face);
      // TODO, here the variable sunSize and headPosition are updated
      // they need to be scaled for the screen.
      // the face object contains the features by name, get them out.
    }
  } 
  requestAnimationFrame(drawVideo);
}


// Draws the current eyes onto the canvas, directly from video streams
async function drawFace(face){
   let i = 0;
//    ctx.fillStyle = 'cyan';
//    ctx.font = "10px Arial";
    //sunSize = 10;
    //console.log(face);
    getHeadPosition(face.mesh);
    for (pt of face.scaledMesh){
        
        
        //debugger
        if(i == FACE_UP || i == FACE_DOWN || i == NOSE_TIP){
            //console.log(pt[0], pt[1]);
            // let headHeight = 200;
            // var x = map_range(nose.x, video.videoWidth, 0, 0, canvasWebGL.width);
            // var y = map_range(nose.y, 0, video.videoHeight, 0, canvasWebGL.height);
            // var z = map_range(headHeight, 0, vid_height, 0, 1.0);
            // headPosition[0] = x;
            // headPosition[1] = y;
            // sunSize = z;
            // ctx.beginPath();
            // ctx.ellipse(pt[0], pt[1], 3,3, 0, 0, 2*Math.PI)
            // ctx.fill();

            // ctx.strokeText(i, pt[0], pt[1]);
        }
        i = i+1;
    }
}

function getHeadPosition(mesh){
    let nose = mesh[NOSE_TIP]
    let faceUp = mesh[FACE_UP]
    let faceDown = mesh[FACE_DOWN]
    let headHeight = getHeadHeight(faceUp[0], faceDown[1])

    let x = map_range(nose[0], 0 , video.videoWidth, 0, canvas.width);
    let y = map_range(nose[1], 0, video.videoHeight, 0, canvas.height);
    let z = map_range(headHeight, 0, video.videoHeight, 0, 1.0) * 0.8;

    headPosition = [x, y]
    sunSize = z
    console.log(nose)
}

function updateFacePositionFromMouse(mousePos){
    let x = map_range(mousePos.x, video.videoWidth, 0, 0, canvas.width);
    let y = map_range(mousePos.y, 0, video.videoHeight, 0, canvas.height);

    headPosition = [x, y]
    sunSize = 0.6   
}

function getHeadHeight(top, bottom){
    if (!top || !bottom){
        return 200
    } else {
        return bottom -top
    }
}

function removeWaitingMessage(){
    let msg = document.getElementById('wait')
    msg.remove()
}

async function main() {
   fmesh = await facemesh.load({maxFaces:3});
   setupCamera()
    .then(function(video){
        removeWaitingMessage()
        video.play()
        drawVideo();
        renderPrediction();
    })
    .catch(function(){
        removeWaitingMessage()
        console.log("Camera not available, fallback to mouse")
        addEventListener("mousemove", (event) => {
            headPosition = [event.clientX, (canvas.height - event.clientY)]        
        })
        addEventListener("wheel", (event) => {
            let inc = event.wheelDelta / 1200
            if (inc > 0 && sunSize + inc < SUN_SIZE_MAX){
                sunSize += inc
            } else if (inc < 0 && sunSize - inc > SUN_SIZE_MIN){
                sunSize += inc
            }
        })
    })
    // Set up front-facing camera
    // await setupCamera();
    // let videoWidth = video.videoWidth;
    // let videoHeight = video.videoHeight;
    // video.play()

    // HTML Canvas for the video feed
    canvas = document.getElementById('facecanvas');
    if (debug) {
        canvas.width = video.videoWidth
        canvas.height = video.videoHeight
    } else {
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
    }

    // canvas.width = window.innerWidth;
    // canvas.height = window.innerHeight;

    let regl = createREGL({
            canvas: canvas
    })

    const drawTriangle = regl({
        frag: `
            precision mediump float;
            uniform float uSunSize;
            uniform vec2 iResolution;
            uniform vec2 uHead;

            float circleSmooth(in vec2 st, in vec2 pos, in float begin, in float end) {
                float pct = 0.0;
                pct = 1. - smoothstep(begin, end, distance(st, pos));
                return pct;
            }

            float rectangleGradientBottom(in vec2 st, in vec2 origin, in vec2 dimensions, float smoothness) {
                vec2 center = step(origin, st); // it is actually the bottom left cornter
                float pct = center.x * center.y;
                vec2 full = step(1.0 - origin - dimensions, 1.0 - st);
                float height = origin.y+dimensions.y;
                pct *= full.x * full.y;
                pct *= smoothstep(height, origin.y+smoothness,st.y);
                return pct;
            }

            //  Function from IÃ±igo Quiles
            //  www.iquilezles.org/www/articles/functions/functions.htm
            float parabola( float x, float k ){
                return pow( 4.0*x*(1.0-x), k );
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / iResolution.xy;
                vec2 headNorm = uHead/iResolution;
                // use parabola function to get the y coordinate
                //vec2 m = vec2(headNorm.x, parabola(headNorm.x, 1.2));
                vec2 m = vec2(headNorm.x, headNorm.y);
                vec3 color = vec3(0.1, 0.4, 0.9);
                color += vec3(0.9-m.y,0.6-uv.y, -(1.0-m.y));
                uv.x *= iResolution.x / iResolution.y;
                m.x *= iResolution.x / iResolution.y;
                vec2 recPos = vec2(0.0, 0.0);

                // kind of sun, with a lot of imagination
                color.rg += circleSmooth(uv, vec2(m), 0.05, 0.15 + uSunSize);
                float turnOffSky = smoothstep(0.25, 0.27,m.y);
                color*= turnOffSky;

                // earth
                vec3 earth = vec3(vec2(rectangleGradientBottom(uv, recPos, vec2(40.0, 0.3), 0.16)), 0.0);
                earth.r += 1.0 -m.y;
                color += earth;
                float turnOffEarth = smoothstep(0.09, 0.25,m.y);
                color*= turnOffEarth;

                gl_FragColor = vec4(color, 1.0);
            }`,

        vert: `
            precision mediump float;
            attribute vec3 position;

            void main() {
                gl_Position = vec4(position, 1);
            }`,

        attributes: {
            position: regl.buffer([
                [[-1, -1, 0], [-1, 1, 0], [1, 1, 0]],
                [[1, 1, 0], [1, -1, 0], [-1, -1, 0]]
            ])
        },

        uniforms: {
            iResolution: regl.prop('resolution'),
            uSunSize: regl.prop('sunSize'),
            uHead: regl.prop('headPosition')
        },
        count: 6
    })    

    regl.frame(function (context) {
        drawTriangle({
            resolution: [context.drawingBufferWidth, context.drawingBufferHeight],
            sunSize: sunSize,
            headPosition: headPosition
        })
    })
}

main()
</script>


</head>

<body>
    <div id="wait">Wait for camera to be detected, otherwise use the mouse as input</div>
    <video autoplay muted 
        playsinline hidden id="video"
        style=" top:0px; left: 500px"
        width="300" height="225"
        >
	</video>
    <canvas id="facecanvas"></canvas>
</body>
</html>